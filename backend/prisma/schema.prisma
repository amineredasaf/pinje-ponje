// Pinjponj is a game where you can play with your friends and have fun
// this is the schema of the database

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id              Int     @id @unique @default(autoincrement())
  Hashpassword    String?
  email           String  @unique
  intraid         Int?
  twofactor       Boolean @default(false)
  twoFactorSecret String?
  // GameOfP1        Game[]   @relation("P1")
  // GameOfP2        Game[]   @relation("P2")

  Rooms    RoomMembership[]
  messages ChatMessage[]
  profile  Profile?
  // roomMember			RoomMember?
}

// add level and rank and xp fake data and store achievements in the database and rankes 

model Profile {
  id             Int       @id @unique @default(autoincrement())
  username       String    @unique
  login          String    @unique
  // campus      String // # at the creation the campus came from intra
  avatar         String?
  // phonenumber    String?
  // status         Status    @default(ONLINE) // # enum [in game, online, offline]
  // CurrentMap     String
  // UnlockedMap    String[]
  Rank           Rank      @default(UNRANKED) // # enum [bronze, silver, gold, platinum, diamond, master, grandmaster, challenger]
  level          Int       @default(0)
  Friends        Int[]
  blockedBy      Profile[] @relation("UserBlocked")
  blocking       Profile[] @relation("UserBlocked")
  pendingRequest Profile[] @relation("UserPending")
  sentRequest    Profile[] @relation("UserPending")
  createdAt      DateTime  @default(now())
  updatedAt      DateTime  @default(now()) @updatedAt
  user           User      @relation(fields: [userid], references: [id], onDelete: Cascade)
  userid         Int       @unique
}


model RoomMembership {
  id       Int      @id @default(autoincrement())
  role     ChatRole
  state    MemberState @default(ACTIVE)
  unmuteTime DateTime?
  user     User     @relation(fields: [userId], references: [id])
  userId   Int
  room     ChatRoom @relation(fields: [roomId], references: [id], onDelete: Cascade)
  roomId   Int
}

model ChatMessage {
  id        Int      @id @default(autoincrement())
  content   String
  room      ChatRoom @relation(fields: [roomId], references: [id], onDelete: Cascade)
  roomId    Int
  user      User     @relation(fields: [userId], references: [id])
  userId    Int
  createdAt DateTime @default(now())
}

model ChatRoom {
  id          Int              @id @default(autoincrement())
  name        String           @unique
  password    String?
  roomType    RoomType         @default(DM)
  members     RoomMembership[]
  messages    ChatMessage[]
  updatedAt   DateTime         @updatedAt
  createdAt   DateTime         @default(now())
}

// model Game {
//   id        Int        @id @unique @default(autoincrement())
//   Player1   User       @relation("P1", fields: [player1id], references: [id], onDelete: Cascade)
//   Player2   User       @relation("P2", fields: [player2id], references: [id])
//   player1id Int        @unique
//   player2id Int        @unique
//   p1Score   Int        @default(0)
//   p2Score   Int        @default(0)
//   p1Result  gameResult @default(DRAW)
//   p2Result  gameResult @default(DRAW)
//   status    gameStatus @default(PENDING)
//   createdAt DateTime   @default(now())
//   updatedAt DateTime   @default(now()) @updatedAt
// }

// model ChatRoom {
//   id        Int          @id @unique @default(autoincrement())
// 	name      String?
// 	avatar		String?
// 	type			roomType
// 	password	String?
// 	// //probably should add invite too
//   // members   RoomMember[]
//   // message   Messages?
//   createdAt DateTime     @default(now())
//   updatedAt DateTime     @default(now()) @updatedAt
// }

// model RoomMember {
//   id        Int         @id @unique @default(autoincrement())
//   chatRoom  ChatRoom[]
//   role      ChatRole
//   STATE     MemberState
//   // message   Messages?
// 	user      User        @relation(fields: [userId], references: [id])
// 	userId    Int         @unique
//   createdAt DateTime    @default(now())
//   updatedAt DateTime    @default(now()) @updatedAt
// }

// model Messages {
//   id         Int        @id @unique @default(autoincrement())
//   content    String
//   sender     RoomMember @relation(fields: [senderId], references: [id])
//   senderId   Int        @unique
//   receiver   ChatRoom   @relation(fields: [receiverId], references: [id])
//   receiverId Int        @unique
//   createdAt  DateTime   @default(now())
//   updatedAt  DateTime   @default(now()) @updatedAt
// }

enum RoomType {
  PUBLIC
  PROTECTED
  PRIVATE
  DM
}

enum MemberState {
  ACTIVE
  MUTED
  BANNED
}

enum ChatRole {
  MEMBER
  ADMIN
  OWNER
}

enum GameResult {
  WIN
  LOSE
  DRAW
}

// # enum [in game, online, offline]
enum Status {
  INGAME
  ONLINE
  OFFLINE
}

enum GameStatus {
  PENDING
  IN_PROGRESS
  FINISHED
}

// # enum [bronze, silver, gold, platinum, diamond, master, grandmaster, challenger]
enum Rank {
  UNRANKED
  BRONZE
  SILVER
  GOLD
  PLATINUM
  DIAMOND
  MASTER
  GRANDMASTER
  CHALLENGER
}

// # thinking about Self Reations Disvanteges
// # https://www.prisma.io/docs/concepts/components/prisma-schema/relations#self-relations
// # thinking about the best practice to send the data to the client
// # thinking about the best structure to store the data
// # thinking about the best way to query the data
// # thinking about the best way to update the data
// # thinking about the best way to delete the data
// # thinking about the best way to create the data
// # thinking about the best way to handle the data
// # thinking about the best way to split the user and the profile
